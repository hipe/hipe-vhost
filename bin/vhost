#!/usr/bin/env ruby
require 'open3'
require 'ostruct'
require 'ruby-debug'; puts "ERASE THIS RUBY DEBUG LINE"
module Hipe

  class Fail < RuntimeError; end

  module AsciiFormattey
    def wordwrap(text,width)
      text.split("\n").map do |line|
        line.length > width ? line.gsub(
          /(.{1,#{width}})(\s+|$)/, "\\1\n").strip : line
      end * "\n"
    end

    def indent(text, margin, width)
      wordwrap(text,width).gsub(/\n/, "\n"+(' '*margin))
    end
  end

  module CliLitey
    # if this thing exceeds 30 lines of code use hipe-core/interfacey
    include AsciiFormattey
    def run(argv)
      return usage_text unless argv[0] && @actions[argv[0]]
      action = argv.shift
      action = help if (['-h','--help'].include?(action))
      meth = action # 'execute_'+action
      send(meth, argv)
    end

    def program_name
      File.basename $PROGRAM_NAME
    end

    def help(args)
      usage_text+"\n\n"
    end
  end

  module FileyCoyote
    def make_backup_copy orig_path
      append = Time.now.strftime('%Y-%m-%d_%H:%M:%S')
      new_name = %{#{orig_path}.bak.#{append}}
      i = 1
      while File.exist? new_name  # very unlikely
        new_name = %{#{orig_path}.bak.#{append}.#{i}}
        i += 1
      end
      begin
        FileUtils.copy_file orig_path, new_name
      rescue Errno::EACCES => e
        e.extend DetailedException
        e.filename = new_name
        raise e
      end
      puts "made backup copy: #{new_name}"
    end
  end

  module DetailedException
    def self.extend_object(base)
     base.instance_eval do
        @__info = {}
     end
     super
    end
    def method_missing name, *args, &blah
      if /^(.+)=$/ =~ name.to_s
        @__info[$1.to_sym] = args[0]
      else
        @__info[name.to_sym]
      end
    end
  end

  module Systematic
    def sistum command
      stdin, stdout, stderr = Open3.popen3 command
      err = stderr.read; out = stdout.read
      raise Fail.new(err) if "" != err
      out.chop
    end

    def sistum2 command
      stdin, stdout, stderr = Open3.popen3 command
      err = stderr.read; out = stdout.read
      [out.chop,err.chop]
    end
  end

  class AsciiTableLite
    def initialize(*cols)
      @cols = cols
      @pipe = '|'
      @cona = '+'
      @rule = '-'
      @rulesep = @rule * 3
      @sep = " #{@pipe} "
    end
    def render rows
      @rows = rows
      @maxes = Hash[*@cols.map{|x|[x, x.to_s.length]}.flatten]
      prerendereds = []
      rows.each do |info|
        preprender = OpenStruct.new
        @cols.each do |col|
          cel = info.send(col).to_s
          preprender.send("#{col}=",cel)
          if (@maxes[col].nil? || cel.length > @maxes[col])
            @maxes[col] = cel.length
          end
        end
        prerendereds.push preprender
      end
      @lines = [go_sep]
      @lines.push go_headers
      @lines.push go_sep
      prerendereds.each do |info|
        @lines.push go_row info
      end
      @lines.push go_sep
      @lines * "\n"
    end

    ## private

    def go_sep
      "#{@cona}#{@rule}"<<
      "#{@cols.map{|x| @rule * @maxes[x]} * @rulesep }"<<
      "#{@rule}#{@cona}"
    end

    def go_headers
      "#{@pipe} "<<
      (@cols.map{|x|x.to_s.ljust(@maxes[x])}* @sep)<<
      " #{@pipe}"
    end

    def go_row row
      "#{@pipe} "<<
      (@cols.map{|x|row.send(x).to_s.ljust(@maxes[x])}*@sep)<<
      " #{@pipe}"
    end
  end

  module Vhost

    Hardcoded = OpenStruct.new(
      :execs      => ['apachectl','apache2ctl'],
      :httpd_conf  => '/etc/apache2/httpd.conf',
      :doc_roots  => '/var/sites/',
      :vhost_confs => '/etc/apache2/sites-enabled/',
      :etc_hosts   => '/etc/hosts'
    );

    class Fail < RuntimeError; end

    class Cli
      include Hipe::CliLitey, Hipe::Systematic
      Table = Hipe::AsciiTableLite

      def initialize
        @actions = {'help'=>1,'explain'=>1,'hosts'=>1,'confs'=>1,
          'dump' =>1, 'list'=>1
        }
        @path = {}
        %w(httpd_conf doc_roots vhost_confs etc_hosts).each do |guy|
          @path[guy.to_sym] = Hardcoded.send(guy)
        end
        get_orientated_with_your_environment
        @path = OpenStruct.new(@path)
      end

      ###### command implementations

      def explain argv; explain_text end

      def usage_text
        <<-END.gsub(/^ {8}/,'')
        do some stuff with your apache server virtualhosts.

        Usage: #{program_name} COMMAND [ARGUMENTS]

        Commands:
          help         show this screen
          explain      explains the steps involved in adding a virtualhost
                       -- you should understand this before using this script
          hosts        just shows the parsed version of the /etc/hosts file
          confs        just list the known vhosts per the sites-enabled dir.
          dump         a tableized version of `apachectl -t -D DUMP_VHOSTS`
          list         report everything you know about anything
        END
      end

      def explain_text
        <<-END.gsub(/^ {8}/,'')
          HOW TO ADD A VIRTUALHOST (the really short version):
          1) ~> locate httpd.conf # then jump to the relevant lines at the end
          2) copy paste a new virtualhost section into the file -or-
             add such vhost config file into a folder that gets Include'd
          3) ~> locate /etc/hosts # find the right file, it's usually this one
          4) copy paste your line
          5) apache(2?)ctl stop
          6) apache(2?)ctl start
        END
      end

      def hosts argv
        rows = parse_hosts.sort!{|x,y| x.name <=> y.name }
        Table.new(:ip, :name).render(rows)
      end

      def confs argv
        rows = parse_confs.sort!{|x,y| x.server_name <=> y.server_name }
        Table.new(:server_name,:document_root).render(rows)
      end

      def dump argv
        parse = parse_dump_vhosts
        puts Table.new(:server_name, :port, :conf_path).
          render(parse.entries)
        puts "\n"
        puts Table.new(:missing_docroot).
          render(parse.missing_docroots)
        ''
      end

      def list argv
        infos = all_info.sort!{|x,y| x.host <=> y.host}
        Table.new(
          :host, :host_ok, :ip, :port, :docroot, :docroot_ok, :conf
        ).render(infos)
      end


      ###### top secret implementationz

      def parse_hosts
        File.read(@path.etc_hosts).scan(
          %r{(127\.0\.0\.1)\s+([[:print:]]+)[\s\t]*$}
        ).map do |match|
          OpenStruct.new(:ip => match[0], :name => match[1])
        end
      end

      def parse_confs
        conf = ApacheConfProxy.new @path.httpd_conf
        confs = conf.sites_enabled_confs
        confs.delete_if{|x| x.document_root == '' }
        confs.sort!{|x,y| x.server_name <=> y.server_name}
      end

      def parse_dump_vhosts
        cmd = "#{@path.apachectl} -t -D DUMP_VHOSTS"
        out,err = sistum2(cmd)
        raise Fail.new("huh? #{out}") unless ""==out
        p = DumpParse.new err # @todo plan on having this crap out a lot
        p
      end

      def get_orientated_with_your_environment
        list = Hardcoded.execs
        infos = list.map do |executable|
          OpenStruct.new(
            'which' => sistum("which #{executable}")
          )
        end
        infos.delete_if{|x| ""==x.which}
        case infos.length
          when 0:
            raise Fail.new("#{sistum('whoami')} has neither "<<
              (list * ' nor ') << "within his or her executable path."<<
              "  I can be of no help to you."
            )
          when 1: # fallthru
          else
            raise Fail.new("#{sistum('whoami')} has all of these in"<<
              " his or her path: "<< (infos.map(&:which) * ' and ')<<'.'<<
              "  As this is a zero-configuration jobbie, I have no idea"<<
              " what to do."
            )
        end
        @path[:apachectl] =  infos[0].which
      end

      def all_info
        hosts = parse_hosts
        confs = parse_confs
        dumps = parse_dump_vhosts  # entries, missing_doctroots
        missings = Hash[*
          dumps.missing_docroots.each.map{|x| [x.missing_docroot, 1]}.flatten
        ]
        master = Hash.new(){|h,k| h[k] = OpenStruct.new(:host=>k) }
        hosts.each do |host|
          item = master[host.name]
          item.ip = host.ip
          item.host_ok = 'ok'
        end
        confs.each do |conf|
          item = master[conf.server_name]
          item.docroot = conf.document_root
          item.docroot_ok = (missings[conf.document_root]) ? 'missing' : 'ok'
        end
        dumps.entries.each do |dump|
          item = master[dump.server_name]
          item.conf = dump.conf_path
          item.port = dump.port
        end
        master.values
      end
    end # Cli

    class DumpParse
      attr_reader :missing_docroots, :entries
      def initialize str
        lines = str.split("\n")
        @missing_docroots = []
        infos = []
        lines.each do |line|
          case line
            when /^Warning: DocumentRoot \[(.+)\] does not exist$/:
              @missing_docroots.push OpenStruct.new(:missing_docroot => $1)
            when /^.*is a NameVirtualHost$/: #skip
            when "VirtualHost configuration:": # skip
            when /^ {9}default server (.+) \((.+)\:\d+\)$/:
              infos.push OpenStruct.new(
                :server_name => $1, :conf_path => $2, :port => nil
              )
            when /^ {9}port ([^ ]+) namevhost (.+) \((.+)\:\d+\)$/:
              infos.push OpenStruct.new(
                :server_name => $2, :conf_path => $3, :port => $1
              )
            when /^Syntax OK$/: #skip for now end
            else
              raise Fail.new("we suck: parse fail:\n#{line.inspect}")
          end
        end
        @entries = infos
      end
    end


    class ApacheConfProxy
      SitesEnabledRe = %r|^ *Include +([^\n]*sites-enabled/?) *$|m
      # code for pasring the file itself left behind in bf91c
      def initialize path
        @path = path
        @contents = File.read path
      end

      # this project it is hard coded to expect that there is
      # only one such entry in the file
      def sites_enabled_path
        arr = @contents.scan(SitesEnabledRe).map{|x| x[0]}
        case arr.length
          when 0: nil
          when 1: arr[0]
          else arr
        end
      end

      def sites_enabled_confs
        path1 = sites_enabled_path
        paths = Dir[File.join(path1,'*.conf')]
        paths.map do |path|
          VhostConfProxy.new(path)
        end
      end
    end

    class VhostConfProxy < ApacheConfProxy
      def initialize *args
        super(*args)
        @cache = {}
      end
      def document_root
        _get('DocumentRoot')
      end
      def server_name
        _get('ServerName')
      end
      def _get thing
        @cache[thing] ||= begin
          re = Regexp.new('^ *'<<Regexp.escape(thing)<<
          '  *"?([^"]+)"? *$')
          matches = @contents.scan(re)
          case matches.length
            when 0: ""
            when 1: matches[0][0]
            else matches.map{|x| x[0]}.join(',')
          end
        end
      end
    end
  end # Vhost
end # Hipe

puts Hipe::Vhost::Cli.new.run ARGV
